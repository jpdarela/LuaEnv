namespace LuaEnv.Core

open System
open System.IO
open System.Diagnostics
open System.Text.Json
open System.Text.Json.Serialization

// Configuration types
type BuildType =
    | StaticRelease
    | StaticDebug
    | DllRelease
    | DllDebug
    override this.ToString() =
        match this with
        | StaticRelease -> "Static Release"
        | StaticDebug -> "Static Debug"
        | DllRelease -> "DLL Release"
        | DllDebug -> "DLL Debug"

// Custom JSON converter for BuildType discriminated union
type BuildTypeConverter() =
    inherit JsonConverter<BuildType>()

    override _.Read(reader: byref<Utf8JsonReader>, typeToConvert: Type, options: JsonSerializerOptions) =
        let value = reader.GetString()
        match value with
        | "StaticRelease" -> StaticRelease
        | "StaticDebug" -> StaticDebug
        | "DllRelease" -> DllRelease
        | "DllDebug" -> DllDebug
        | _ -> StaticRelease // default fallback

    override _.Write(writer: Utf8JsonWriter, value: BuildType, options: JsonSerializerOptions) =
        let stringValue =
            match value with
            | StaticRelease -> "StaticRelease"
            | StaticDebug -> "StaticDebug"
            | DllRelease -> "DllRelease"
            | DllDebug -> "DllDebug"
        writer.WriteStringValue(stringValue)

type LuaInstallation = {
    Version: string
    Path: string
    BuildType: BuildType
    LuaRocksVersion: string
    InstallDate: DateTime
    Alias: string  // Mandatory alias - used as folder name and key
}

type LuaEnvConfig = {
    GlobalVersion: string option  // Can be alias
    Installations: Map<string, LuaInstallation>  // Key is alias
    CachePath: string
    LastUpdate: DateTime
}

module Configuration =
    let private configPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".luaenv", "config.json")
    let private versionsPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".luaenv", "versions")

    let getConfigPath () = configPath
    let getVersionsPath () = versionsPath

    let loadConfig () =
        if File.Exists(configPath) then
            try
                let json = File.ReadAllText(configPath)
                let options = JsonSerializerOptions()
                options.Converters.Add(BuildTypeConverter())
                JsonSerializer.Deserialize<LuaEnvConfig>(json, options)
            with
            | ex ->
                printfn $"Warning: Failed to load config: {ex.Message}"
                { GlobalVersion = None; Installations = Map.empty; CachePath = ""; LastUpdate = DateTime.Now }
        else
            { GlobalVersion = None; Installations = Map.empty; CachePath = ""; LastUpdate = DateTime.Now }

    let saveConfig (config: LuaEnvConfig) =
        Directory.CreateDirectory(Path.GetDirectoryName(configPath)) |> ignore
        let options = JsonSerializerOptions(WriteIndented = true)
        options.Converters.Add(BuildTypeConverter())
        let json = JsonSerializer.Serialize(config, options)
        File.WriteAllText(configPath, json)

module PythonScripts =
    // Path to the Python scripts (looks for backend folder or current directory)    let scriptBasePath =
        let assemblyLocation = System.Reflection.Assembly.GetExecutingAssembly().Location
        let currentDir = Path.GetDirectoryName(assemblyLocation)
        
        // Try to find the Python scripts in these locations (in order of preference):
        let searchPaths = [
            // 1. Check if there's a backend folder relative to the executable
            Path.Combine(currentDir, "backend")
            // 2. Check if there's a backend folder one level up (for development)
            let parent1 = Directory.GetParent(currentDir)
            if parent1 <> null then Path.Combine(parent1.FullName, "backend") else ""
            // 3. Check if there's a backend folder two levels up
            let parent2 = if Directory.GetParent(currentDir) <> null then Directory.GetParent(Directory.GetParent(currentDir).FullName) else null
            if parent2 <> null then Path.Combine(parent2.FullName, "backend") else ""
            // 4. Check if there's a backend folder three levels up
            let parent3 = if parent2 <> null then Directory.GetParent(parent2.FullName) else null
            if parent3 <> null then Path.Combine(parent3.FullName, "backend") else ""
            // 5. Check if there's a backend folder four levels up (for dotnet run scenario)
            let parent4 = if parent3 <> null then Directory.GetParent(parent3.FullName) else null
            if parent4 <> null then Path.Combine(parent4.FullName, "backend") else ""
            // 6. Check if there's a backend folder five levels up
            let parent5 = if parent4 <> null then Directory.GetParent(parent4.FullName) else null
            if parent5 <> null then Path.Combine(parent5.FullName, "backend") else ""
            // 7. Check current directory (legacy/fallback)
            currentDir
            // 8. Check parent directory (for development scenarios)
            if Directory.GetParent(currentDir) <> null then Directory.GetParent(currentDir).FullName else ""
        ]
        
        let rec findScriptsPath (paths: string list) =
            match paths with
            | [] -> None
            | path :: remainingPaths ->
                if path <> "" then
                    let configFile = Path.Combine(path, "config.py")
                    if File.Exists(configFile) then
                        Some path
                    else
                        findScriptsPath remainingPaths
                else
                    findScriptsPath remainingPaths
        
        findScriptsPath searchPaths

    let runPythonScriptWithProgress scriptName args =
        match scriptBasePath with
        | Some basePath ->
            let fullScriptPath = Path.Combine(basePath, scriptName)
            if not (File.Exists(fullScriptPath)) then
                Error $"Python script not found: {fullScriptPath}"
            else
                let psi = ProcessStartInfo("python", $"\"{fullScriptPath}\" {args}")
                psi.RedirectStandardOutput <- false  // Show output in real-time
                psi.RedirectStandardError <- false   // Show errors in real-time
                psi.UseShellExecute <- false
                psi.WorkingDirectory <- basePath

                try
                    let proc = Process.Start(psi)
                    proc.WaitForExit()
                    Ok proc.ExitCode
                with
                | ex -> Error $"Failed to run Python script: {ex.Message}"
        | None ->
            Error "Could not find Python scripts directory"

    let runPythonScript scriptName args =
        match scriptBasePath with
        | Some basePath ->
            let fullScriptPath = Path.Combine(basePath, scriptName)
            if not (File.Exists(fullScriptPath)) then
                Error $"Python script not found: {fullScriptPath}"
            else
                let psi = ProcessStartInfo("python", $"\"{fullScriptPath}\" {args}")
                psi.RedirectStandardOutput <- true
                psi.RedirectStandardError <- true
                psi.UseShellExecute <- false
                psi.WorkingDirectory <- basePath

                try
                    let proc = Process.Start(psi)
                    proc.WaitForExit()
                    Ok (proc.ExitCode, proc.StandardOutput.ReadToEnd(), proc.StandardError.ReadToEnd())
                with
                | ex -> Error $"Failed to run Python script: {ex.Message}"
        | None ->
            Error "Could not find Python scripts directory"

module VersionManager =
    open Configuration
    open PythonScripts

    let listInstalled () =
        let config = loadConfig()
        config.Installations
        |> Map.toList
        |> List.map (fun (alias, installation) ->
            $"{alias} ({installation.Version}, {installation.BuildType})")
        |> List.sort

    let listAvailable () =
        match runPythonScript "config.py" "--discover" with
        | Ok (0, output, _) ->
            let lines = output.Split('\n') |> Array.map (fun line -> line.Trim())

            // Find the start of Lua versions section
            let luaStartIdx =
                lines
                |> Array.tryFindIndex (fun line -> line.Contains("Found") && line.Contains("available Lua versions:"))

            match luaStartIdx with
            | Some startIdx ->
                // Take lines after the "Found X available Lua versions:" line
                // until we hit the LuaRocks section or end of relevant content
                lines
                |> Array.skip (startIdx + 1)
                |> Array.takeWhile (fun line ->
                    not (line.Contains("Found") && line.Contains("LuaRocks")) &&
                    not (line.Contains("Also available for")) &&
                    not (line.StartsWith("To use")) &&
                    not (line.StartsWith("Cache file:")))
                |> Array.filter (fun line -> line.StartsWith("- "))
                |> Array.map (fun line ->
                    let version = line.Substring(2).Split(' ').[0]  // Remove "- " prefix and "(CURRENT)" suffix
                    version)
                |> Array.toList
            | None -> []
        | Ok (_, _, error) ->
            printfn $"Error discovering versions: {error}"
            []
        | Error msg ->
            printfn $"Error: {msg}"
            []

    let listAvailableLuaRocks () =
        match runPythonScript "config.py" "--discover" with
        | Ok (0, output, _) ->
            let lines = output.Split('\n') |> Array.map (fun line -> line.Trim())

            // Find the start of LuaRocks versions section
            let luaRocksStartIdx =
                lines
                |> Array.tryFindIndex (fun line -> line.Contains("Found") && line.Contains("available LuaRocks versions"))

            match luaRocksStartIdx with
            | Some startIdx ->
                // Take lines after the "Found X available LuaRocks versions..." line
                // until we hit the "Also available for" line or end of relevant content
                lines
                |> Array.skip (startIdx + 1)
                |> Array.takeWhile (fun line ->
                    not (line.StartsWith("Also available for")) &&
                    not (line.StartsWith("To use")) &&
                    not (line.StartsWith("Cache file:")))
                |> Array.filter (fun line -> line.StartsWith("- "))
                |> Array.map (fun line ->
                    let version = line.Substring(2).Split(' ').[0]  // Remove "- " prefix and "(CURRENT)" suffix
                    version)
                |> Array.toList
            | None -> []
        | Ok (_, _, error) ->
            printfn $"Error discovering LuaRocks versions: {error}"
            []
        | Error msg ->
            printfn $"Error: {msg}"
            []

    let setupLuaRocksConfig installPath luaVersion luaRocksVersion =
        // Setup LuaRocks configuration in the installation directory
        let luaRocksConfigDir = Path.Combine(installPath, "etc", "luarocks")
        let luaRocksConfigFile = Path.Combine(luaRocksConfigDir, "config-5.4.lua")

        Directory.CreateDirectory(luaRocksConfigDir) |> ignore

        let luaExePath = Path.Combine(installPath, "bin", "lua.exe")
        let luacExePath = Path.Combine(installPath, "bin", "luac.exe")
        let rocksTreePath = Path.Combine(installPath, ".rocks")  // Hidden folder for packages

        let configContent = $"""-- LuaRocks configuration for Lua {luaVersion}
-- Generated by LuaEnv F#
rocks_trees = {{
    {{ name = "user", root = [[{rocksTreePath}]] }},
    {{ name = "system", root = [[{installPath}]] }}
}}

lua_interpreter = [[{luaExePath}]]
lua_dir = [[{installPath}]]

variables = {{
    LUA_DIR = [[{installPath}]],
    LUA_BINDIR = [[{Path.Combine(installPath, "bin")}]],
    LUA_INCDIR = [[{Path.Combine(installPath, "include")}]],
    LUA_LIBDIR = [[{Path.Combine(installPath, "lib")}]]
}}

-- Windows-specific settings
external_deps_dirs = {{
    [[{installPath}]]
}}
"""

        try
            File.WriteAllText(luaRocksConfigFile, configContent)
            printfn $"[SUCCESS] LuaRocks configuration created at: {luaRocksConfigFile}"
        with
        | ex -> printfn $"[WARNING] Could not create LuaRocks config: {ex.Message}"

    let installWithLuaRocks luaVersion luaRocksVersion buildType alias dryRun =
        // Alias is now mandatory for installations
        let aliasName = alias |> Option.defaultWith (fun () ->
            failwith "Alias is required for all installations. Please provide an alias using --alias <name>")

        let effectiveLuaVersion =
            if String.IsNullOrEmpty(luaVersion) then
                // Get latest Lua version
                match listAvailable() with
                | latest::_ -> latest
                | [] -> "5.4.8" // fallback
            else luaVersion

        let effectiveLuaRocksVersion =
            match luaRocksVersion with
            | Some version -> version
            | None ->
                // Get latest LuaRocks version
                match listAvailableLuaRocks() with
                | latest::_ -> latest
                | [] -> "3.12.2" // fallback

        printfn $"Installing Lua {effectiveLuaVersion} with LuaRocks {effectiveLuaRocksVersion} ({buildType}) as '{aliasName}'..."

        // Use alias as the installation folder name
        let installPath = Path.Combine(getVersionsPath(), aliasName)

        if dryRun then
            printfn "[INFO] DRY RUN - Would perform the following actions:"
            printfn "  - Lua version: %s" effectiveLuaVersion
            printfn "  - LuaRocks version: %s" effectiveLuaRocksVersion
            printfn "  - Build type: %s" (buildType.ToString())
            printfn "  - Alias: %s" aliasName
            printfn "  - Installation path: %s" installPath
            printfn "  - Would create temporary build_config.txt"
            printfn "  - Would run Python setup_lua.py with use_lua.ps1 integration"
            printfn "  - Would setup self-contained LuaRocks configuration"
            printfn "[SUCCESS] Dry run completed successfully"
            true
        else
            // Check if alias already exists
            let config = loadConfig()
            if config.Installations.ContainsKey(aliasName) then
                printfn $"[ERROR] Installation with alias '{aliasName}' already exists"
                printfn "   Use 'luaenv uninstall {aliasName}' to remove it first"
                false
            else
                // Real installation process
                // Use alias as the installation folder name
                let installPath = Path.Combine(getVersionsPath(), aliasName)

                // Build arguments for Python setup_lua.py
                let args =
                    match buildType with
                    | StaticRelease -> ""
                    | StaticDebug -> "--debug"
                    | DllRelease -> "--dll"
                    | DllDebug -> "--dll --debug"

                // Manage temporary build configuration
                match PythonScripts.scriptBasePath with
                | Some pythonDir ->
                    let buildConfigPath = Path.Combine(pythonDir, "build_config.txt")
                    let backupConfigPath = Path.Combine(pythonDir, "build_config.txt.backup")

                    // Backup original config if it exists
                    let originalConfigExists = File.Exists(buildConfigPath)
                    if originalConfigExists then
                        try
                            File.Copy(buildConfigPath, backupConfigPath, true)
                            printfn "[INFO] Backed up existing build_config.txt"
                        with ex ->
                            printfn $"[WARNING] Could not backup build config: {ex.Message}"

                    // Create temporary build config with our specified versions
                    let majorMinor = if effectiveLuaVersion.Length >= 3 then effectiveLuaVersion.Substring(0, 3) else "5.4"
                    let configContent = $"""# Temporary build configuration for LuaEnv F#
# Generated on {DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")}
LUA_VERSION={effectiveLuaVersion}
LUA_MAJOR_MINOR={majorMinor}
LUAROCKS_VERSION={effectiveLuaRocksVersion}
LUAROCKS_PLATFORM=windows-64"""

                    try
                        File.WriteAllText(buildConfigPath, configContent)
                        printfn $"[INFO] Created temporary build config for Lua {effectiveLuaVersion} + LuaRocks {effectiveLuaRocksVersion}"

                        // Build the install command with prefix
                        let pythonArgs = if String.IsNullOrWhiteSpace(args) then $"--prefix \"{installPath}\"" else $"{args} --prefix \"{installPath}\""
                        printfn $"[RUN] Running: python setup_lua.py {pythonArgs}"
                        printfn "[INFO] Installation output will be shown below..."
                        printfn ""

                        match runPythonScriptWithProgress "setup_lua.py" pythonArgs with
                        | Ok 0 ->
                            printfn ""
                            printfn "[SUCCESS] Python installation completed successfully"

                            // Clean up unwanted files created by Python scripts
                            try
                                let prefixFile = Path.Combine(getVersionsPath(), ".lua_prefix.txt")
                                if File.Exists(prefixFile) then
                                    File.Delete(prefixFile)
                                    printfn "[CLEAN] Cleaned up .lua_prefix.txt"
                            with
                            | ex -> printfn $"[WARNING] Could not clean up .lua_prefix.txt: {ex.Message}"

                            // Since we don't have output from the progress version, use the specified LuaRocks version
                            let detectedLuaRocksVersion = effectiveLuaRocksVersion

                            // Setup LuaRocks configuration and tree
                            printfn "[CONFIG] Setting up LuaRocks configuration..."
                            setupLuaRocksConfig installPath effectiveLuaVersion detectedLuaRocksVersion

                            // Configure LuaRocks tree using use_lua.ps1
                            let rocksTreePath = Path.Combine(installPath, ".rocks")
                            printfn "[CONFIG] Configuring LuaRocks tree..."
                            Directory.CreateDirectory(rocksTreePath) |> ignore

                            // Call use_lua.ps1 to set up the environment with the custom tree
                            match PythonScripts.scriptBasePath with
                            | Some pythonDir ->
                                let useLuaScript = Path.Combine(pythonDir, "use-lua.ps1")
                                if File.Exists(useLuaScript) then
                                    let setupArgs = $"-Tree \"{rocksTreePath}\" -Lua \"{installPath}\""
                                    printfn $"[RUN] Running: pwsh \"{useLuaScript}\" {setupArgs}"

                                    let psi = ProcessStartInfo("pwsh", $"-ExecutionPolicy Bypass -File \"{useLuaScript}\" {setupArgs}")
                                    psi.UseShellExecute <- false
                                    psi.WorkingDirectory <- pythonDir
                                    psi.RedirectStandardOutput <- true
                                    psi.RedirectStandardError <- true

                                    try
                                        let proc = Process.Start(psi)
                                        proc.WaitForExit()
                                        let output = proc.StandardOutput.ReadToEnd()
                                        let error = proc.StandardError.ReadToEnd()

                                        if proc.ExitCode = 0 then
                                            printfn "[SUCCESS] LuaRocks tree configuration completed"
                                        else
                                            printfn $"[WARNING] use-lua.ps1 completed with exit code {proc.ExitCode}"
                                            if not (String.IsNullOrWhiteSpace(error)) then
                                                printfn $"Error output: {error}"
                                    with
                                    | ex -> printfn $"[WARNING] Could not run use-lua.ps1: {ex.Message}"
                                else
                                    printfn "[WARNING] use-lua.ps1 not found, skipping tree setup"
                            | None ->
                                printfn "[WARNING] Python scripts directory not found, skipping use-lua.ps1 setup"

                            // Update LuaEnv configuration
                            printfn "[CONFIG] Updating LuaEnv configuration..."
                            let config = loadConfig()
                            let installation = {
                                Version = effectiveLuaVersion
                                Path = installPath
                                BuildType = buildType
                                LuaRocksVersion = detectedLuaRocksVersion
                                InstallDate = DateTime.Now
                                Alias = aliasName
                            }

                            let newConfig = {
                                config with
                                    Installations = config.Installations.Add(aliasName, installation)
                                    LastUpdate = DateTime.Now
                            }
                            saveConfig newConfig

                            printfn ""
                            printfn "[SUCCESS] Successfully installed Lua + LuaRocks!"
                            printfn $"   Lua version: {effectiveLuaVersion}"
                            printfn $"   LuaRocks version: {detectedLuaRocksVersion}"
                            printfn $"   Build type: {buildType}"
                            printfn $"   Alias: {aliasName}"
                            printfn $"   Location: {installPath}"
                            printfn ""
                            let binPath = Path.Combine(installPath, "bin")
                            printfn "[INFO] To use this installation:"
                            printfn $"   luaenv global {aliasName}"
                            printfn $"   # or add to PATH: {binPath}"
                            true

                        | Ok exitCode ->
                            printfn "[ERROR] Python installation failed with exit code %d" exitCode
                            printfn "   Check the output above for error details"
                            false

                        | Error msg ->
                            printfn "[ERROR] Error running Python script: %s" msg
                            false

                    finally
                        // Restore original config file
                        try
                            if originalConfigExists && File.Exists(backupConfigPath) then
                                File.Copy(backupConfigPath, buildConfigPath, true)
                                File.Delete(backupConfigPath)
                                printfn "[INFO] Restored original build_config.txt"
                            elif File.Exists(buildConfigPath) then
                                File.Delete(buildConfigPath)
                                printfn "[INFO] Cleaned up temporary build_config.txt"
                        with ex ->
                            printfn "[WARNING] Could not restore build config: %s" ex.Message

                | None ->
                    printfn "[ERROR] Could not find Python scripts directory"
                    printfn "   Make sure you're running from the correct location"
                    false

    let install version buildType =
        installWithLuaRocks version None buildType None false

    let uninstall alias =
        printfn $"Uninstalling Lua installation '{alias}'..."
        let config = loadConfig()
        match config.Installations.TryFind(alias) with
        | Some installation ->
            // Manual cleanup - remove the entire installation directory
            if Directory.Exists(installation.Path) then
                try
                    Directory.Delete(installation.Path, true)
                    printfn "[SUCCESS] Removed installation directory: %s" installation.Path
                with
                | ex -> printfn "[WARNING] Could not remove directory: %s" ex.Message

            // Update config - remove installation by alias
            let newConfig = {
                config with
                    Installations = config.Installations.Remove(alias)
                    GlobalVersion =
                        match config.GlobalVersion with
                        | Some globalAlias when globalAlias = alias -> None
                        | other -> other
            }
            saveConfig newConfig
            printfn "[SUCCESS] Successfully uninstalled Lua installation '%s'" alias
            true
        | None ->
            printfn "[ERROR] Lua installation '%s' is not found" alias
            printfn "Available installations:"
            let config = loadConfig()
            for kvp in config.Installations do
                let installation = kvp.Value
                printfn "  - %s (Lua %s, %s)" kvp.Key installation.Version (installation.BuildType.ToString())
            false

    let setGlobal alias =
        let config = loadConfig()
        if config.Installations.ContainsKey(alias) then
            let newConfig = { config with GlobalVersion = Some alias }
            saveConfig newConfig
            printfn "[SUCCESS] Set global Lua version to '%s'" alias
            true
        else
            printfn "[ERROR] Lua installation '%s' is not found" alias
            printfn "Available installations:"
            for kvp in config.Installations do
                let installation = kvp.Value
                printfn "  - %s (Lua %s, %s)" kvp.Key installation.Version (installation.BuildType.ToString())
            false

    let setLocal alias =
        let config = loadConfig()
        if config.Installations.ContainsKey(alias) then
            let installation = config.Installations.[alias]
            let currentDir = Environment.CurrentDirectory
            let versionFile = Path.Combine(currentDir, ".luaenv-version")
            let activateScript = Path.Combine(currentDir, "activate-lua.ps1")

            try
                // Create .luaenv-version file
                File.WriteAllText(versionFile, alias)

                // Create activation script that leverages the existing use-lua.ps1 and setup-luarocks.bat
                let rocksTreePath = Path.Combine(installation.Path, ".rocks")
                let scriptContent =
                    match PythonScripts.scriptBasePath with
                    | Some pythonDir ->
                        let useLuaScript = Path.Combine(pythonDir, "use-lua.ps1")
                        let setupLuaRocksScript = Path.Combine(pythonDir, "build_scripts", "setup-luarocks.bat")
                        $"""# LuaEnv Local Environment Activation Script for '{alias}'
# Generated by LuaEnv F# - Auto-activates Lua {installation.Version} ({installation.BuildType})
# This script uses the existing use-lua.ps1 and setup-luarocks.bat for robust environment setup

param([switch]$Quiet, [switch]$SetupLuaRocks)

# Paths for this installation
$luaPath = "{installation.Path}"
$binPath = "{Path.Combine(installation.Path, "bin")}"
$luarocksPath = "{Path.Combine(installation.Path, "luarocks")}"
$rocksTreePath = "{rocksTreePath}"

# Check if use-lua.ps1 exists and use it for robust setup
$useLuaScript = "{useLuaScript.Replace("\\", "\\\\")}"
$setupLuaRocksScript = "{setupLuaRocksScript.Replace("\\", "\\\\")}"

if (Test-Path $useLuaScript) {{
    if (-not $Quiet) {{
        Write-Host "[LAUNCH] Activating Lua {installation.Version} ({installation.BuildType}) using use-lua.ps1..." -ForegroundColor Cyan
    }}

    # Use the existing use-lua.ps1 with our specific installation paths
    & $useLuaScript -Lua "$luaPath" -Tree "$rocksTreePath"

    # Ensure LuaRocks is in PATH (sometimes use-lua.ps1 doesn't add it correctly)
    if (Test-Path "$luarocksPath\\luarocks.exe") {{
        if ($env:PATH -notmatch [regex]::Escape($luarocksPath)) {{
            $env:PATH = "$luarocksPath;$env:PATH"
        }}
    }}

    # Optional: Run setup-luarocks.bat for complete LuaRocks configuration
    if ($SetupLuaRocks -and (Test-Path $setupLuaRocksScript)) {{
        if (-not $Quiet) {{
            Write-Host "[INFO] Running setup-luarocks.bat for complete LuaRocks configuration..." -ForegroundColor Yellow
        }}
        & cmd /c "$setupLuaRocksScript" "$luaPath"
    }}

    if (-not $Quiet) {{
        Write-Host ""
        Write-Host "[SUCCESS] Environment activated for directory: {currentDir}" -ForegroundColor Green
        Write-Host "   Alias: {alias}" -ForegroundColor Gray
        Write-Host "   Lua: {installation.Version} ({installation.BuildType})" -ForegroundColor Gray
        Write-Host "   Installation: {installation.Path}" -ForegroundColor Gray
        Write-Host "   LuaRocks tree: {rocksTreePath}" -ForegroundColor Gray
        Write-Host ""
        Write-Host "[READY] Ready to use:" -ForegroundColor Yellow
        Write-Host "   lua script.lua" -ForegroundColor Cyan
        Write-Host "   luarocks install <package>" -ForegroundColor Cyan
        Write-Host "   luarocks list" -ForegroundColor Cyan
        Write-Host ""
        if (Test-Path $setupLuaRocksScript) {{
            Write-Host "[TIP] For complete LuaRocks setup, run:" -ForegroundColor Blue
            Write-Host "   . .\\activate-lua.ps1 -SetupLuaRocks" -ForegroundColor Cyan
        }}
    }}
}} else {{
    # Fallback if use-lua.ps1 is not available
    if (-not $Quiet) {{
        Write-Warning "use-lua.ps1 not found, using fallback environment setup"
    }}

    # Basic environment setup
    $env:PATH = "$binPath;$luarocksPath;$env:PATH"
    $env:LUA_PATH = "{rocksTreePath}\\share\\lua\\5.4\\?.lua;{rocksTreePath}\\share\\lua\\5.4\\?\\init.lua;$env:LUA_PATH"
    $env:LUA_CPATH = "{rocksTreePath}\\lib\\lua\\5.4\\?.dll;$env:LUA_CPATH"

    # Set LuaRocks configuration
    $configPath = "{Path.Combine(installation.Path, "etc", "luarocks", "config-5.4.lua")}"
    if (Test-Path $configPath) {{
        $env:LUAROCKS_CONFIG = $configPath
    }}

    # Try to set up basic MSVC environment
    try {{
        $vswhere = "$env:ProgramFiles(x86)\\Microsoft Visual Studio\\Installer\\vswhere.exe"
        if (Test-Path $vswhere) {{
            $vsPath = & $vswhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath
            if ($vsPath) {{
                $vsDevShell = Join-Path $vsPath "Common7\\Tools\\Launch-VsDevShell.ps1"
                if (Test-Path $vsDevShell) {{
                    & $vsDevShell -Arch "amd64" -SkipAutomaticLocation -ErrorAction SilentlyContinue
                    if (-not $Quiet) {{
                        Write-Host "[INFO] MSVC environment loaded for compiling native modules" -ForegroundColor Green
                    }}
                }}
            }}
        }}
    }} catch {{
        if (-not $Quiet) {{
            Write-Warning "Could not load MSVC environment. Native module compilation may not work."
        }}
    }}

    # Optional: Run setup-luarocks.bat for complete LuaRocks configuration
    if ($SetupLuaRocks -and (Test-Path $setupLuaRocksScript)) {{
        if (-not $Quiet) {{
            Write-Host "[INFO] Running setup-luarocks.bat for complete LuaRocks configuration..." -ForegroundColor Yellow
        }}
        & cmd /c "$setupLuaRocksScript" "$luaPath"
    }}

    if (-not $Quiet) {{
        Write-Host "[SUCCESS] Basic environment activated for Lua {installation.Version} ({installation.BuildType})" -ForegroundColor Green
        Write-Host "   Installation: {installation.Path}" -ForegroundColor Gray
        Write-Host "   LuaRocks tree: {rocksTreePath}" -ForegroundColor Gray
        if (Test-Path $setupLuaRocksScript) {{
            Write-Host ""
            Write-Host "[TIP] For complete LuaRocks setup, run:" -ForegroundColor Blue
            Write-Host "   . .\\activate-lua.ps1 -SetupLuaRocks" -ForegroundColor Cyan
        }}
    }}
}}
"""
                    | None ->
                        $"""# LuaEnv Local Environment Activation Script for '{alias}'
# Generated by LuaEnv F# - Auto-activates Lua {installation.Version} ({installation.BuildType})
# Warning: Python build scripts not found, using basic setup

param([switch]$Quiet)

$binPath = "{Path.Combine(installation.Path, "bin")}"
$luarocksPath = "{Path.Combine(installation.Path, "luarocks")}"
$rocksTreePath = "{rocksTreePath}"

# Basic environment setup
$env:PATH = "$binPath;$luarocksPath;$env:PATH"
$env:LUA_PATH = "$rocksTreePath\\share\\lua\\5.4\\?.lua;$rocksTreePath\\share\\lua\\5.4\\?\\init.lua;$env:LUA_PATH"
$env:LUA_CPATH = "$rocksTreePath\\lib\\lua\\5.4\\?.dll;$env:LUA_CPATH"

# Set LuaRocks configuration if available
$configPath = "{Path.Combine(installation.Path, "etc", "luarocks", "config-5.4.lua")}"
if (Test-Path $configPath) {{
    $env:LUAROCKS_CONFIG = $configPath
}}

if (-not $Quiet) {{
    Write-Host "[SUCCESS] Activated Lua {installation.Version} ({installation.BuildType}) for this directory" -ForegroundColor Green
    Write-Host "   Installation: {installation.Path}" -ForegroundColor Gray
    Write-Host "   LuaRocks tree: $rocksTreePath" -ForegroundColor Gray
    Write-Host "   Note: For MSVC compilation support, install Python build scripts" -ForegroundColor Yellow
}}
"""

                File.WriteAllText(activateScript, scriptContent)

                printfn $"[SUCCESS] Set local Lua version to '{alias}' for {currentDir}"
                printfn $"[FILE] Created .luaenv-version file"
                printfn $"[SCRIPT] Created activation script: activate-lua.ps1"
                printfn ""
                printfn "[INFO] To activate the environment in this directory, run:"
                printfn $"   . .\\activate-lua.ps1"
                printfn ""
                printfn "[QUIET] For quiet activation (no output):"
                printfn $"   . .\\activate-lua.ps1 -Quiet"
                printfn ""
                printfn "[INFO] For complete LuaRocks setup (recommended for development):"
                printfn $"   . .\\activate-lua.ps1 -SetupLuaRocks"
                printfn ""
                printfn "[LAUNCH] Alternative execution methods:"
                printfn $"   PowerShell: pwsh -ExecutionPolicy Bypass -File .\\activate-lua.ps1"
                printfn $"   Command: powershell -ExecutionPolicy Bypass -File activate-lua.ps1"
                printfn ""
                printfn "[TIP] After activation, you can use 'lua' and 'luarocks' commands directly!"
                let rocksPath = Path.Combine(installation.Path, ".rocks")
                printfn $"   LuaRocks packages will be installed to: {rocksPath}"
                true
            with
            | ex ->
                printfn $"[ERROR] Could not create local environment files: {ex.Message}"
                false
        else
            printfn $"[ERROR] Lua installation '{alias}' is not found"
            printfn "Available installations:"
            for kvp in config.Installations do
                let installation = kvp.Value
                printfn "  - %s (Lua %s, %s)" kvp.Key installation.Version (installation.BuildType.ToString())
            false

    let showConfig () =
        let config = loadConfig()
        printfn "LuaEnv Configuration (Windows):"
        printfn $"  Config path: {getConfigPath()}"
        printfn $"  Versions path: {getVersionsPath()}"

        // Show Python script discovery information
        match PythonScripts.scriptBasePath with
        | Some path -> printfn $"  Python scripts found at: {path}"
        | None -> printfn "  [WARNING]  Python scripts not found!"

        let globalVersionText = config.GlobalVersion |> Option.defaultValue "None"
        printfn $"  Global version: {globalVersionText}"

        printfn $"  Installed versions: {config.Installations.Count}"
        config.Installations |> Map.iter (fun alias install ->
            printfn $"    {alias} ({install.BuildType}) - {install.Path}")

    let validateConfig () =
        match runPythonScript "config.py" "--check" with
        | Ok (0, _, _) -> true
        | _ -> false

module Utils =
    let cleanCache () =
        match PythonScripts.runPythonScript "clean.py" "" with
        | Ok (0, _, _) ->
            printfn "[SUCCESS] Cache cleaned successfully"
            true
        | Ok (_, _, error) ->
            printfn $"[ERROR] Failed to clean cache: {error}"
            false
        | Error msg ->
            printfn $"[ERROR] Error: {msg}"
            false

    let getCurrentVersion () =
        let config = Configuration.loadConfig()

        // First check for local .luaenv-version file
        let currentDir = Environment.CurrentDirectory
        let versionFile = Path.Combine(currentDir, ".luaenv-version")

        if File.Exists(versionFile) then
            let localVersion = File.ReadAllText(versionFile).Trim()
            Some localVersion
        else
            // Fall back to global version
            config.GlobalVersion

    let getCurrentInstallation () =
        match getCurrentVersion() with
        | Some versionKey ->
            let config = Configuration.loadConfig()
            config.Installations.TryFind(versionKey)
        | None -> None

    let whichLua () =
        match getCurrentInstallation() with
        | Some installation ->
            let luaPath = Path.Combine(installation.Path, "bin", "lua.exe")
            if File.Exists(luaPath) then
                printfn $"Lua path: {luaPath}"
                printfn $"Version: {installation.Version}"
                printfn $"Build type: {installation.BuildType}"
                printfn $"LuaRocks version: {installation.LuaRocksVersion}"
                printfn $"Alias: {installation.Alias}"
                Some luaPath
            else
                printfn $"[ERROR] Lua executable not found at: {luaPath}"
                None
        | None ->
            printfn "[ERROR] No Lua version set. Use 'luaenv global <alias>' or 'luaenv local <alias>'"
            printfn "   Available versions:"
            let config = Configuration.loadConfig()
            config.Installations |> Map.iter (fun alias install ->
                printfn $"     {alias}")
            None

    let runLua (args: string) =
        match getCurrentInstallation() with
        | Some installation ->
            let luaPath = Path.Combine(installation.Path, "bin", "lua.exe")
            if File.Exists(luaPath) then
                let psi = ProcessStartInfo(luaPath, args)
                psi.UseShellExecute <- false
                psi.WorkingDirectory <- Environment.CurrentDirectory

                try
                    let proc = Process.Start(psi)
                    proc.WaitForExit()
                    proc.ExitCode
                with
                | ex ->
                    printfn $"[ERROR] Error running Lua: {ex.Message}"
                    1
            else
                printfn $"[ERROR] Lua executable not found at: {luaPath}"
                1
        | None ->
            printfn "[ERROR] No Lua version set. Use 'luaenv global <alias>' or 'luaenv local <alias>'"
            1

    let generateUseScript () =
        match getCurrentInstallation() with
        | Some installation ->
            let binPath = Path.Combine(installation.Path, "bin")
            let rocksTreePath = Path.Combine(installation.Path, ".rocks")

            printfn "To use this Lua installation in your current session:"
            printfn ""
            printfn "PowerShell:"
            printfn $"  $env:PATH = \"{binPath};$env:PATH\""
            printfn $"  $env:LUA_PATH = \"{rocksTreePath}\\share\\lua\\5.4\\?.lua;{rocksTreePath}\\share\\lua\\5.4\\?\\init.lua;$env:LUA_PATH\""
            printfn $"  $env:LUA_CPATH = \"{rocksTreePath}\\lib\\lua\\5.4\\?.dll;$env:LUA_CPATH\""
            printfn ""
            printfn "Command Prompt:"
            printfn "  set \"PATH=%s;%%PATH%%\"" binPath
            printfn "  set \"LUA_PATH=%s\\share\\lua\\5.4\\?.lua;%s\\share\\lua\\5.4\\?\\init.lua;%%LUA_PATH%%\"" rocksTreePath rocksTreePath
            printfn "  set \"LUA_CPATH=%s\\lib\\lua\\5.4\\?.dll;%%LUA_CPATH%%\"" rocksTreePath
            printfn ""
            printfn "Or use the use-lua.ps1 script:"
            match PythonScripts.scriptBasePath with
            | Some pythonDir ->
                let useLuaScript = Path.Combine(pythonDir, "use-lua.ps1")
                if File.Exists(useLuaScript) then
                    printfn $"  pwsh -ExecutionPolicy Bypass -File \"{useLuaScript}\" -Tree \"{rocksTreePath}\" -Lua \"{installation.Path}\""
                else
                    printfn "  (use-lua.ps1 script not found)"
            | None ->
                printfn "  (use-lua.ps1 script not found)"
            printfn ""
            printfn $"Current installation: {installation.Alias} (Lua {installation.Version}, {installation.BuildType})"
        | None ->
            printfn "[ERROR] No Lua version set. Use 'luaenv global <alias>' or 'luaenv local <alias>'"
            printfn "Available installations:"
            let config = Configuration.loadConfig()
            if config.Installations.IsEmpty then
                printfn "  (No installations found)"
            else
                config.Installations |> Map.iter (fun alias install ->
                    printfn "  - %s (Lua %s, %s)" alias install.Version (install.BuildType.ToString()))
